import requests
from datetime import datetime, date
import time
import pandas as pd
import re
from bs4 import BeautifulSoup
import json
import os # Para salvar o arquivo

# =================================================================
# üîß CONFIGURA√á√ïES
# =================================================================

HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
    "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8"
}

# =================================================================
# üéØ FUN√á√ïES DE BUSCA REAIS DO DOU (As suas fun√ß√µes)
# =================================================================

def buscar_dou_json_embedded(nome, data_inicio, data_fim):
    """ Busca no DOU extraindo JSON embutido na p√°gina - M√âTODO PRINCIPAL """
    url = "https://www.in.gov.br/consulta/-/buscar/dou"
    
    params = {
        "q": f'"{nome}"',
        "s": "todos",
        "exactDate": "personalizado",
        "sortType": "0",
        "publishFrom": data_inicio.strftime("%d-%m-%Y"),
        "publishTo": data_fim.strftime("%d-%m-%Y")
    }
    
    print(f"[INFO] Tentando buscar JSON embutido para {nome}...")
    try:
        response = requests.get(url, params=params, headers=HEADERS, timeout=30)
        
        if response.status_code == 200:
            soup = BeautifulSoup(response.content, 'html.parser')
            script_tag = soup.find('script', id='_br_com_seatecnologia_in_buscadou_BuscaDouPortlet_params')
            
            if script_tag and script_tag.string:
                try:
                    json_text = script_tag.string.strip()
                    dados = json.loads(json_text)
                    items = dados.get('jsonArray', [])
                    
                    if items:
                        print(f"  [SUCESSO] {len(items)} resultados via JSON embutido.")
                        return processar_items_json(items, nome)
                    else:
                        print(f"  [AVISO] JSON vazio encontrado. Tentando HTML...")
                        
                except json.JSONDecodeError as e:
                    print(f"  [ERRO] Falha ao decodificar JSON: {e}. Tentando HTML...")
            
            # Tentar extrair do HTML se o JSON falhar ou n√£o existir
            print(f"  [INFO] Tentando extrair resultados do HTML...")
            return extrair_resultados_html_direct(response.text, nome)
            
        else:
            print(f"  [ERRO] Erro HTTP {response.status_code}. Tentando HTML...")
            
    except Exception as e:
        print(f"  [ERRO] Erro na busca (JSON): {e}. Voltando para HTML simples...")
    
    return []

# ----------------------------------------------------------------------
# O c√≥digo continua com as suas fun√ß√µes auxiliares e a fun√ß√£o de processamento:
# ----------------------------------------------------------------------

def processar_items_json(items, nome_busca):
    # ... (Sua fun√ß√£o processar_items_json inalterada)
    resultados = []
    
    for item in items:
        conteudo = item.get('content', '')
        titulo = item.get('title', '')
        data_pub = item.get('pubDate', '')
        url = item.get('url', '')
        hierarchy = item.get('hierarchyList', [])
        pub_name = item.get('pubName', '')
        
        tipo = identificar_tipo_publicacao(titulo, conteudo, nome_busca)
        
        resultados.append({
            'Nome Buscado': nome_busca,
            'T√≠tulo': titulo,
            'Data': formatar_data(data_pub),
            'Tipo': tipo,
            '√ìrg√£o': hierarchy[-1] if hierarchy else "√ìrg√£o n√£o identificado",
            'URL': f"https://www.in.gov.br{url}" if url and not url.startswith('http') else url,
            'Se√ß√£o': pub_name,
            'Trecho Relevante': extrair_trecho_relevante(conteudo, nome_busca),
            'Cargo': extrair_cargo(conteudo),
            'Nome na Pub.': extrair_nome_publicacao(conteudo, nome_busca),
        })
    return resultados

def extrair_resultados_html_direct(html_content, nome_busca):
    # ... (Sua fun√ß√£o extrair_resultados_html_direct inalterada)
    soup = BeautifulSoup(html_content, 'html.parser')
    resultados = []
    
    resultados_divs = soup.find_all(['div', 'li'], class_=['search-result', 'resultado', 'item-busca']) 
    
    if not resultados_divs:
        resultados_divs = soup.find_all('div', class_=lambda x: x and 'resultado' in x)

    for div in resultados_divs:
        try:
            titulo_elem = div.find(['h2', 'h3'], class_=lambda x: x and ('title' in x or 'titulo' in x))
            if not titulo_elem:
                 link_elem = div.find('a', string=lambda t: t and nome_busca.upper() in t.upper())
                 titulo = link_elem.get_text(strip=True) if link_elem else "Sem t√≠tulo"
                 url = link_elem.get('href', '') if link_elem else ''
            else:
                 link_elem = titulo_elem.find('a')
                 titulo = titulo_elem.get_text(strip=True) if titulo_elem else "Sem t√≠tulo"
                 url = link_elem.get('href', '') if link_elem else ''

            if titulo == "Sem t√≠tulo" or nome_busca.upper() not in titulo.upper():
                continue

            conteudo_elem = div.find(['p', 'div', 'span'], class_=lambda x: x and ('abstract' in x or 'content' in x or 'trecho' in x))
            conteudo = conteudo_elem.get_text(strip=True) if conteudo_elem else div.get_text(strip=True) 
            
            data_elem = div.find(['span', 'p', 'div'], class_=lambda x: x and ('date' in x or 'data-publicacao' in x))
            data = data_elem.get_text(strip=True) if data_elem else ''
            
            orgao = "√ìrg√£o n√£o identificado (HTML)"
            if ':' in titulo:
                 orgao = titulo.split(':')[0].strip()

            tipo = identificar_tipo_publicacao(titulo, conteudo, nome_busca)
            
            resultados.append({
                'Nome Buscado': nome_busca,
                'T√≠tulo': titulo,
                'Data': formatar_data(data),
                'Tipo': tipo,
                '√ìrg√£o': orgao,
                'URL': f"https://www.in.gov.br{url}" if url and not url.startswith('http') else url,
                'Se√ß√£o': "Se√ß√£o n√£o definida (HTML)",
                'Trecho Relevante': extrair_trecho_relevante(conteudo, nome_busca),
                'Cargo': extrair_cargo(conteudo),
                'Nome na Pub.': extrair_nome_publicacao(conteudo, nome_busca),
            })
                
        except Exception as e:
             continue
    
    print(f"  [AVISO] {len(resultados)} resultados via HTML (Fallback).")
    return resultados

# ----------------------------------------------------------------------
# Suas fun√ß√µes auxiliares...
# ----------------------------------------------------------------------

def identificar_tipo_publicacao(titulo, conteudo, nome_busca):
    # (Manter sua l√≥gica de identifica√ß√£o de tipo)
    texto = f"{titulo} {conteudo}".upper()
    
    if 'PORTARIA' in titulo.upper():
        if any(palavra in texto for palavra in ['NOMEAR', 'NOMEA√á√ÉO', 'POSSE']):
            return "NOMEA√á√ÉO"
        elif any(palavra in texto for palavra in ['DESIGNAR', 'DISPENSAR']):
            return "DESIGNA√á√ÉO"
        else:
            return "PORTARIA"
    
    if 'EDITAL' in titulo.upper():
        if 'CONCURSO' in texto:
            return "EDITAL CONCURSO"
        else:
            return "EDITAL"
    
    if any(palavra in texto for palavra in ['NOMEAR', 'NOMEA√á√ÉO', 'POSSE']):
        return "NOMEA√á√ÉO"
    elif any(palavra in texto for palavra in ['APROVADO', 'CLASSIFICADO', 'RESULTADO FINAL']):
        return "APROVADO"
    elif any(palavra in texto for palavra in ['CONVOCAR', 'CONVOCA√á√ÉO']):
        return "CONVOCADO"
    elif 'CONCURSO P√öBLICO' in texto:
        return "CONCURSO P√öBLICO"
    
    return "OUTROS"

def extrair_cargo(conteudo):
    padroes = [
        r'cargo de\s+([^,\.]+)', r'cargo:\s*([^\n\.]+)', r'para o cargo de\s+([^,\.]+)', 
        r'fun√ß√£o de\s+([^,\.]+)', r'encargo de\s+([^,\.]+)'
    ]
    for padrao in padroes:
        match = re.search(padrao, conteudo, re.IGNORECASE)
        if match:
            cargo = match.group(1).strip()
            cargo = re.sub(r'^(de|para|como|,|\.)', '', cargo, flags=re.IGNORECASE).strip()
            if cargo and len(cargo) > 3:
                return cargo
    return "N√£o identificado"

def extrair_trecho_relevante(conteudo, nome_busca):
    try:
        padrao = re.escape(nome_busca)
        match = re.search(padrao, conteudo, re.IGNORECASE)
        if match:
            inicio = max(0, match.start() - 100)
            fim = min(len(conteudo), match.end() + 100)
            trecho = conteudo[inicio:fim]
            trecho_destacado = re.sub(padrao, f"<b>{match.group()}</b>", trecho, flags=re.IGNORECASE)
            return f"...{trecho_destacado}..."
    except:
        pass
    return conteudo[:200] + "..." if len(conteudo) > 200 else conteudo

def extrair_nome_publicacao(conteudo, nome_busca):
    try:
        padrao = re.escape(nome_busca)
        match = re.search(padrao, conteudo, re.IGNORECASE)
        return match.group() if match else nome_busca
    except:
        return nome_busca

def formatar_data(data_string):
    if not data_string: return "N/A"
    try:
        for fmt in ["%Y-%m-%d", "%d/%m/%Y", "%d-%m-%Y"]:
            try:
                if len(data_string) >= 10:
                    data_obj = datetime.strptime(data_string[:10], fmt)
                    return data_obj.strftime("%d/%m/%Y")
            except ValueError:
                continue
    except:
        pass
    return data_string

# ----------------------------------------------------------------------
# FUN√á√ÉO PRINCIPAL: Gera o Arquivo HTML
# ----------------------------------------------------------------------

def gerar_html_dos_resultados(nome, data_inicio, data_fim, arquivo_saida="resultados_dou.html"):
    """
    Executa a busca e gera um arquivo HTML est√°tico com a tabela de resultados.
    """
    print("=================================================================")
    print(f"üöÄ INICIANDO BUSCA DOU para: {nome}")
    print(f"üìÖ Per√≠odo: {data_inicio.strftime('%d/%m/%Y')} a {data_fim.strftime('%d/%m/%Y')}")
    print("=================================================================")
    
    # 1. Executa a busca
    resultados = buscar_dou_json_embedded(nome, data_inicio, data_fim)
    
    if not resultados:
        print("‚ùå NENHUM RESULTADO ENCONTRADO.")
        return

    # 2. Cria o DataFrame
    df = pd.DataFrame(resultados)
    
    # Colunas que queremos exibir na tabela
    df_html = df[[
        'Nome Buscado', 'Tipo', 'Data', '√ìrg√£o', 'Cargo', 'T√≠tulo', 'Trecho Relevante', 'URL'
    ]]
    
    # 3. Formata√ß√£o HTML e CSS simples (para deixar bonito)
    
    # Adiciona links na coluna URL
    df_html['URL'] = df_html['URL'].apply(lambda x: f'<a href="{x}" target="_blank">Acessar</a>')
    
    # Estilos CSS
    css_style = """
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
        h1 { color: #004d99; border-bottom: 2px solid #ccc; padding-bottom: 10px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; box-shadow: 0 0 20px rgba(0,0,0,0.1); background-color: white; }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #007bff; color: white; cursor: pointer; }
        tr:hover { background-color: #f1f1f1; }
        .success { color: green; font-weight: bold; }
        .info { color: #555; }
        /* Ajuste de largura das colunas importantes */
        td:nth-child(6) { max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        td:nth-child(7) { max-width: 500px; }
    </style>
    """
    
    # Gera o HTML da tabela (sem index e com a classe 'dataframe')
    tabela_html = df_html.to_html(escape=False, index=False, classes='dataframe')
    
    # HTML Final
    html_output = f"""
    <!DOCTYPE html>
    <html lang="pt-BR">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Resultados DOU - {nome}</title>
        {css_style}
        <script>
            // Script para permitir a ordena√ß√£o da tabela (opcional, mas √∫til)
            document.addEventListener('DOMContentLoaded', () => {{
                const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
                const comparer = (idx, asc) => (a, b) => ((v1, v2) => 
                    v1 !== '' && v2 !== '' && !isNaN(v1) && !isNaN(v2) ? v1 - v2 : v1.toString().localeCompare(v2)
                )(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));

                document.querySelectorAll('th').forEach(th => th.addEventListener('click', (() => {{
                    const table = th.closest('table');
                    const tbody = table.querySelector('tbody');
                    Array.from(tbody.querySelectorAll('tr'))
                        .sort(comparer(Array.from(th.parentNode.children).indexOf(th), this.asc = !this.asc))
                        .forEach(tr => tbody.appendChild(tr));
                }})));
            }});
        </script>
    </head>
    <body>
        <h1>Resultados da Busca no DOU</h1>
        <p class="success">‚úÖ **{len(df)} Resultados Encontrados** para: <b>{nome}</b></p>
        <p class="info">Arquivo gerado em: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}</p>
        
        {tabela_html}
        
    </body>
    </html>
    """
    
    # 4. Salvar o arquivo
    with open(arquivo_saida, 'w', encoding='utf-8') as f:
        f.write(html_output)
        
    print(f"\n‚úÖ SUCESSO! Arquivo HTML est√°tico salvo em: {os.path.abspath(arquivo_saida)}")
    print("   Voc√™ pode abrir este arquivo diretamente no seu navegador.")

# ----------------------------------------------------------------------
# EXECU√á√ÉO DA BUSCA
# ----------------------------------------------------------------------

if __name__ == "__main__":
    # üö® DADOS DA BUSCA - AJUSTE AQUI ANTES DE EXECUTAR üö®
    nome_alvo = "JULIANA FERNANDES FARIAS" 
    data_inicio_alvo = date(2023, 10, 1)
    data_fim_alvo = date(2025, 10, 14)
    
    # Chama a fun√ß√£o que executa a busca e gera o HTML
    gerar_html_dos_resultados(nome_alvo, data_inicio_alvo, data_fim_alvo)
